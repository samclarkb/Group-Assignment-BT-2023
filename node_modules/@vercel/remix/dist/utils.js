"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRegExpFromPath = exports.getPathFromRoute = exports.getRouteIterator = exports.isLayoutRoute = exports.calculateRouteConfigHash = exports.getResolvedRouteConfig = exports.findConfig = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const path_to_regexp_1 = require("path-to-regexp");
const SPLAT_PATH = '/:params+';
const configExts = ['.js', '.cjs', '.mjs'];
function findConfig(dir, basename) {
    for (const ext of configExts) {
        const name = basename + ext;
        const file = (0, path_1.join)(dir, name);
        if ((0, fs_1.existsSync)(file))
            return file;
    }
    return undefined;
}
exports.findConfig = findConfig;
function isEdgeRuntime(runtime) {
    return runtime === 'edge' || runtime === 'experimental-edge';
}
function getResolvedRouteConfig(route, routes, configs) {
    let runtime;
    let regions;
    let maxDuration;
    let memory;
    for (const currentRoute of getRouteIterator(route, routes)) {
        const staticConfig = configs.get(currentRoute);
        if (staticConfig) {
            if (typeof runtime === 'undefined' && staticConfig.runtime) {
                runtime = isEdgeRuntime(staticConfig.runtime) ? 'edge' : 'nodejs';
            }
            if (typeof regions === 'undefined') {
                regions = staticConfig.regions;
            }
            if (typeof maxDuration === 'undefined') {
                maxDuration = staticConfig.maxDuration;
            }
            if (typeof memory === 'undefined') {
                memory = staticConfig.memory;
            }
        }
    }
    if (Array.isArray(regions)) {
        regions = Array.from(new Set(regions)).sort();
    }
    if (runtime === 'edge') {
        return { runtime, regions };
    }
    if (regions && !Array.isArray(regions)) {
        throw new Error(`"regions" for route "${route.id}" must be an array of strings`);
    }
    return { runtime: 'nodejs', regions, maxDuration, memory };
}
exports.getResolvedRouteConfig = getResolvedRouteConfig;
function calculateRouteConfigHash(config) {
    const str = JSON.stringify(config);
    return Buffer.from(str).toString('base64url');
}
exports.calculateRouteConfigHash = calculateRouteConfigHash;
function isLayoutRoute(routeId, routes) {
    return routes.some(r => r.parentId === routeId);
}
exports.isLayoutRoute = isLayoutRoute;
function* getRouteIterator(route, routes) {
    let currentRoute = route;
    do {
        yield currentRoute;
        if (currentRoute.parentId) {
            currentRoute = routes[currentRoute.parentId];
        }
        else {
            break;
        }
    } while (currentRoute);
}
exports.getRouteIterator = getRouteIterator;
function getPathFromRoute(route, routes) {
    if (route.id === 'root' ||
        (route.parentId === 'root' && !route.path && route.index)) {
        return { path: 'index', rePath: '/index' };
    }
    const pathParts = [];
    const rePathParts = [];
    for (const currentRoute of getRouteIterator(route, routes)) {
        if (!currentRoute.path)
            continue;
        const currentRouteParts = currentRoute.path.split('/').reverse();
        for (const part of currentRouteParts) {
            if (part.endsWith('?')) {
                if (part.startsWith(':')) {
                    // Optional path parameter
                    pathParts.push(`(${part.substring(0, part.length - 1)})`);
                    rePathParts.push(part);
                }
                else {
                    // Optional static segment
                    const p = `(${part.substring(0, part.length - 1)})`;
                    pathParts.push(p);
                    rePathParts.push(`${p}?`);
                }
            }
            else {
                pathParts.push(part);
                rePathParts.push(part);
            }
        }
    }
    const path = pathParts.reverse().join('/');
    // Replace "/*" at the end to handle "splat routes"
    let rePath = rePathParts.reverse().join('/');
    rePath =
        rePath === '*' ? SPLAT_PATH : `/${rePath.replace(/\/\*$/, SPLAT_PATH)}`;
    return { path, rePath };
}
exports.getPathFromRoute = getPathFromRoute;
function getRegExpFromPath(rePath) {
    const keys = [];
    const re = (0, path_to_regexp_1.pathToRegexp)(rePath, keys);
    return keys.length > 0 ? re : false;
}
exports.getRegExpFromPath = getRegExpFromPath;
//# sourceMappingURL=utils.js.map